{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "markdown-editor",
  "title": "Markdown Editor",
  "description": "A simple Markdown Editor component",
  "dependencies": [
    "lucide-react",
    "@rasenganjs/mdx"
  ],
  "registryDependencies": [
    "button",
    "card"
  ],
  "files": [
    {
      "path": "src/registry/nindo/editors/markdown.tsx",
      "content": "import React, { useState, useCallback, useRef, useEffect, useMemo, ComponentProps } from 'react';\nimport { Card } from \"@/components/common/ui/card\";\nimport { Markdown } from '@rasenganjs/mdx';\nimport { Button } from '@/components/common/ui/button';\nimport { Bold, Braces, CodeXml, Edit2, Eye, Heading1, Heading2, Heading3, Italic, Link2, Quote, Redo2, SquareSplitHorizontal, Undo2 } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\n// ============================================================================\n// TYPES & INTERFACES\n// ============================================================================\n\ntype BlockType = 'paragraph' | 'heading' | 'code' | 'quote' | 'list' | 'image';\ntype ViewMode = 'edit' | 'preview' | 'split';\n\ninterface Block {\n  id: string;\n  type: BlockType;\n  level?: number;\n  startOffset: number;\n  endOffset: number;\n  content: string;\n}\n\ninterface SelectionState {\n  start: number;\n  end: number;\n}\n\ninterface ToolbarAction {\n  id: string;\n  label: string;\n  icon: React.ReactNode;\n  shortcut?: string;\n  handler: (content: string, selection: SelectionState) => {\n    content: string;\n    selection: SelectionState;\n  };\n}\n\n// ============================================================================\n// MARKDOWN PARSING UTILITIES\n// ============================================================================\n\nconst parseBlocks = (content: string): Block[] => {\n  const lines = content.split('\\n');\n  const blocks: Block[] = [];\n  let offset = 0;\n\n  lines.forEach((line, idx) => {\n    const lineLength = line.length + 1;\n    const trimmed = line.trim();\n    \n    let block: Block = {\n      id: `block-${idx}`,\n      type: 'paragraph',\n      startOffset: offset,\n      endOffset: offset + lineLength - 1,\n      content: line\n    };\n\n    const headingMatch = trimmed.match(/^(#{1,6})\\s/);\n    if (headingMatch) {\n      block.type = 'heading';\n      block.level = headingMatch[1].length;\n    } else if (trimmed.startsWith('```')) {\n      block.type = 'code';\n    } else if (trimmed.startsWith('>')) {\n      block.type = 'quote';\n    } else if (trimmed.match(/^[-*+]\\s/) || trimmed.match(/^\\d+\\.\\s/)) {\n      block.type = 'list';\n    } else if (trimmed.match(/^!\\[.*\\]\\(.*\\)/)) {\n      block.type = 'image';\n    }\n\n    blocks.push(block);\n    offset += lineLength;\n  });\n\n  return blocks;\n};\n\nconst getCurrentBlock = (blocks: Block[], cursorPos: number): Block | null => {\n  return blocks.find(b => cursorPos >= b.startOffset && cursorPos <= b.endOffset) || null;\n};\n\nconst mappingBlockToAction = (block: BlockType, level?: number): ToolbarAction[\"id\"] => {\n  switch (block) {\n    case \"heading\": {\n      return `h${level && 0}`;\n    }\n    case 'code': return 'code-block'\n    case 'list': return \"list\";\n    case 'quote': return \"quote\";\n\n    default: return \"\"\n  }\n}\n\n// ============================================================================\n// FORMATTING UTILITIES\n// ============================================================================\n\nconst wrapSelection = (\n  content: string,\n  selection: SelectionState,\n  before: string,\n  after: string = before\n): { content: string; selection: SelectionState } => {\n  const { start, end } = selection;\n  const selectedText = content.slice(start, end);\n  \n  const newContent = \n    content.slice(0, start) + \n    before + selectedText + after + \n    content.slice(end);\n  \n  return {\n    content: newContent,\n    selection: {\n      start: start + before.length,\n      end: end + before.length\n    }\n  };\n};\n\nconst replaceLinePrefix = (\n  content: string,\n  selection: SelectionState,\n  prefix: string\n): { content: string; selection: SelectionState } => {\n  const lines = content.split('\\n');\n  let currentPos = 0;\n  let targetLineIdx = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineLength = lines[i].length + 1;\n    if (selection.start < currentPos + lineLength) {\n      targetLineIdx = i;\n      break;\n    }\n    currentPos += lineLength;\n  }\n\n  lines[targetLineIdx] = lines[targetLineIdx].replace(/^#{1,6}\\s|^>\\s|^[-*+]\\s|^\\d+\\.\\s/, '');\n  \n  if (prefix) {\n    lines[targetLineIdx] = prefix + ' ' + lines[targetLineIdx];\n  }\n\n  const newContent = lines.join('\\n');\n  return {\n    content: newContent,\n    selection: { ...selection }\n  };\n};\n\n// ============================================================================\n// TOOLBAR ACTIONS\n// ============================================================================\n\nconst createToolbarActions = (): ToolbarAction[] => [\n  {\n    id: 'bold',\n    label: 'Bold',\n    icon: <Bold />,\n    shortcut: '⌘B',\n    handler: (content, selection) => wrapSelection(content, selection, '**')\n  },\n  {\n    id: 'italic',\n    label: 'Italic',\n    icon: <Italic />,\n    shortcut: '⌘I',\n    handler: (content, selection) => wrapSelection(content, selection, '_')\n  },\n  {\n    id: 'code',\n    label: 'Inline Code',\n    icon: <CodeXml />,\n    handler: (content, selection) => wrapSelection(content, selection, '`')\n  },\n  {\n    id: 'link',\n    label: 'Link',\n    icon: <Link2 />,\n    shortcut: '⌘K',\n    handler: (content, selection) => {\n      const selectedText = content.slice(selection.start, selection.end) || 'link text';\n      const linkMarkdown = `[${selectedText}](url)`;\n      const newContent = \n        content.slice(0, selection.start) + \n        linkMarkdown + \n        content.slice(selection.end);\n      \n      return {\n        content: newContent,\n        selection: {\n          start: selection.start + selectedText.length + 3,\n          end: selection.start + selectedText.length + 6\n        }\n      };\n    }\n  },\n  {\n    id: 'h1',\n    label: 'Heading 1',\n    icon: <Heading1 />,\n    handler: (content, selection) => replaceLinePrefix(content, selection, '#')\n  },\n  {\n    id: 'h2',\n    label: 'Heading 2',\n    icon: <Heading2 />,\n    handler: (content, selection) => replaceLinePrefix(content, selection, '##')\n  },\n  {\n    id: 'h3',\n    label: 'Heading 3',\n    icon: <Heading3 />,\n    handler: (content, selection) => replaceLinePrefix(content, selection, '###')\n  },\n  {\n    id: 'quote',\n    label: 'Quote',\n    icon: <Quote />,\n    handler: (content, selection) => replaceLinePrefix(content, selection, '>')\n  },\n  {\n    id: 'code-block',\n    label: 'Code Block',\n    icon: <Braces />,\n    handler: (content, selection) => {\n      const before = '```\\n';\n      const after = '\\n```';\n      return wrapSelection(content, selection, before, after);\n    }\n  }\n];\n\n// ============================================================================\n// HOOKS\n// ============================================================================\n\nconst useEditor = (initialContent: string = '') => {\n  const [content, setContent] = useState(initialContent);\n  const [selection, setSelection] = useState<SelectionState>({ start: 0, end: 0 });\n  const [history, setHistory] = useState<string[]>([initialContent]);\n  const [historyIndex, setHistoryIndex] = useState(0);\n\n  const blocks = useMemo(() => parseBlocks(content), [content]);\n  const currentBlock = useMemo(() => getCurrentBlock(blocks, selection.start), [blocks, selection]);\n\n  const updateContent = useCallback((newContent: string, newSelection?: SelectionState) => {\n    setContent(newContent);\n    if (newSelection) setSelection(newSelection);\n    \n    setHistory(prev => [...prev.slice(0, historyIndex + 1), newContent]);\n    setHistoryIndex(prev => prev + 1);\n  }, [historyIndex]);\n\n  const undo = useCallback(() => {\n    if (historyIndex > 0) {\n      setHistoryIndex(prev => prev - 1);\n      setContent(history[historyIndex - 1]);\n    }\n  }, [history, historyIndex]);\n\n  const redo = useCallback(() => {\n    if (historyIndex < history.length - 1) {\n      setHistoryIndex(prev => prev + 1);\n      setContent(history[historyIndex + 1]);\n    }\n  }, [history, historyIndex]);\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.metaKey || e.ctrlKey) && e.key === 'z') {\n        e.preventDefault();\n        if (e.shiftKey) {\n          redo();\n        } else {\n          undo();\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [undo, redo]);\n\n  return {\n    content,\n    selection,\n    blocks,\n    currentBlock,\n    updateContent,\n    setSelection,\n    undo,\n    redo,\n    canUndo: historyIndex > 0,\n    canRedo: historyIndex < history.length - 1\n  };\n};\n\nconst useMarkdownShortcuts = (\n  textareaRef: React.RefObject<HTMLTextAreaElement | null>,\n  updateContent: (content: string, selection?: SelectionState) => void\n) => {\n  useEffect(() => {\n    const textarea = textareaRef?.current;\n    if (!textarea) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const { value, selectionStart, selectionEnd } = textarea;\n      const selection = { start: selectionStart || 0, end: selectionEnd || 0 };\n\n      if (e.key === ' ') {\n        const lines = value.split('\\n');\n        let currentPos = 0;\n        let currentLine = '';\n        \n        for (const line of lines) {\n          if (selectionStart <= currentPos + line.length) {\n            currentLine = line;\n            break;\n          }\n          currentPos += line.length + 1;\n        }\n\n        const shortcuts: Record<string, string> = {\n          '#': '# ',\n          '##': '## ',\n          '###': '### ',\n          '-': '- ',\n          '>': '> ',\n          '```': '```\\n'\n        };\n\n        for (const [trigger, replacement] of Object.entries(shortcuts)) {\n          if (currentLine.trimStart() === trigger) {\n            e.preventDefault();\n            const result = replaceLinePrefix(value, selection, replacement.trim());\n            updateContent(result.content, result.selection);\n            return;\n          }\n        }\n      }\n\n      const pairs: Record<string, string> = {\n        '**': '**',\n        '_': '_',\n        '`': '`',\n        '[': ']',\n        '(': ')',\n        '{': '}',\n        '\"': '\"',\n        \"'\": \"'\"\n      };\n\n      if (pairs[e.key] && selectionStart === selectionEnd) {\n        e.preventDefault();\n        const before = value.slice(0, selectionStart);\n        const after = value.slice(selectionStart);\n        const newContent = before + e.key + pairs[e.key] + after;\n        updateContent(newContent, {\n          start: selectionStart + e.key.length,\n          end: selectionStart + e.key.length\n        });\n        return;\n      }\n\n      if (e.key === 'Tab') {\n        e.preventDefault();\n        const before = value.slice(0, selectionStart);\n        const after = value.slice(selectionEnd);\n        const newContent = before + '  ' + after;\n        updateContent(newContent, {\n          start: selectionStart + 2,\n          end: selectionStart + 2\n        });\n      }\n    };\n\n    textarea.addEventListener('keydown', handleKeyDown);\n    return () => textarea.removeEventListener('keydown', handleKeyDown);\n  }, [textareaRef, updateContent]);\n};\n\n// ============================================================================\n// COMPONENTS\n// ============================================================================\n\nconst EditorToolbar: React.FC<{\n  actions: ToolbarAction[];\n  onAction: (action: ToolbarAction) => void;\n  currentBlock: Block | null;\n  undo: () => void;\n  redo: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n  mode?: ViewMode;\n  setMode?: (mode: ViewMode) => void;\n}> = ({ actions, onAction, currentBlock, undo, redo, canUndo, canRedo, mode, setMode }) => {\n  return (\n    <div className=\"flex items-center justify-between gap-2 h-[50px] px-2 py-3 bg-background border-b border-border\">\n      <div className='flex items-center gap-2'>\n        <div className=\"flex items-center gap-1\">\n          {actions.slice(0, 4).map(action => (\n            <Button\n              key={action.id}\n              onClick={() => onAction(action)}\n              size={\"icon\"}\n            variant={mappingBlockToAction(currentBlock?.type || 'paragraph', currentBlock?.level) === action.id ? \"default\" : \"outline\"}\n              className={\"text-foreground/70\"}\n              title={`${action.label}${action.shortcut ? ` (${action.shortcut})` : ''}`}\n            >\n              {action.icon}\n            </Button>\n          ))}\n        </div>\n        <div className=\"w-px h-6 bg-border\" />\n        <div className=\"flex items-center gap-1\">\n          {actions.slice(4).map(action => (\n            <Button\n              key={action.id}\n              onClick={() => onAction(action)}\n              size={\"icon\"}\n              variant=\"outline\"\n              className=\"text-foreground/70\"\n              title={action.label}\n            >\n              {action.icon}\n            </Button>\n          ))}\n        </div>\n      </div>\n\n      <div className='flex items-center gap-2'>\n        <div className='flex items-center gap-1'>\n          <Button\n            size={\"icon\"} \n            onClick={() => setMode && setMode(\"edit\")}\n            variant={mode === \"edit\" ? \"default\" : \"outline\"} \n            title=\"Edit\"\n          >\n            <Edit2 />\n          </Button>\n          <Button\n            size={\"icon\"} \n            onClick={() => setMode && setMode(\"split\")}\n            variant={mode === \"split\" ? \"default\" : \"outline\"} \n            title=\"Split\"\n          >\n            <SquareSplitHorizontal />\n          </Button>\n          <Button\n            size={\"icon\"} \n            onClick={() => setMode && setMode(\"preview\")}\n            variant={mode === \"preview\" ? \"default\" : \"outline\"} \n            title=\"Preview\"\n          >\n            <Eye />\n          </Button>\n        </div>\n        <div className=\"w-px h-6 bg-border\" />\n        <Button\n          onClick={undo}\n          disabled={!canUndo}\n          size={\"icon\"} \n          variant={\"ghost\"} \n          className=\"text-foreground/70\"\n          title=\"Undo (⌘Z)\"\n        >\n          <Undo2 />\n        </Button>\n        <Button\n          onClick={redo}\n          disabled={!canRedo}\n          size={\"icon\"} \n          variant={\"ghost\"} \n          className=\"text-foreground/70\"\n          title=\"Redo (⌘⇧Z)\"\n        >\n          <Redo2 />\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nconst EditorCore: React.FC<{\n  content: string;\n  onChange: (content: string) => void;\n  onSelectionChange: (selection: SelectionState) => void;\n  textareaRef: React.RefObject<HTMLTextAreaElement | null>;\n  placeholder?: string;\n  className?: ComponentProps<'div'>['className'];\n}> = ({ content, onChange, onSelectionChange, textareaRef, placeholder, className }) => {\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    onChange(e.target.value);\n  };\n\n  const handleSelect = () => {\n    if (textareaRef.current) {\n      onSelectionChange({\n        start: textareaRef.current.selectionStart,\n        end: textareaRef.current.selectionEnd\n      });\n    }\n  };\n\n  return (\n    <div className={cn(\"flex flex-col flex-1\", className)}>\n      <textarea\n        ref={textareaRef}\n        value={content}\n        onChange={handleChange}\n        onSelect={handleSelect}\n        onClick={handleSelect}\n        onKeyUp={handleSelect}\n        placeholder={placeholder || \"Start writing your markdown...\"}\n        spellCheck={false}\n        className=\"flex-1 p-8 text-foreground border-0 font-mono text-[15px] leading-relaxed resize-none outline-none placeholder:text-foreground/70\"\n      />\n    </div>\n  );\n};\n\nconst MarkdownPreview: React.FC<{ content: string }> = ({ content }) => {\n  return (\n    <div className=\"flex-1 overflow-y-auto bg-muted/30\">\n      <div className=\"p-8 max-w-3xl mx-auto\">\n        {content ? <Markdown content={content} className='' /> : (\n          <p className=\"text-muted-foreground text-center mt-24 italic\">Preview will appear here...</p>\n        )}\n      </div>\n    </div>\n  );\n};\n\n// ============================================================================\n// MAIN EDITOR COMPONENT\n// ============================================================================\n\nconst MarkdownEditor = ({\n  defaultContent = \"\",\n  onChangeContent\n}: { defaultContent?: string, onChangeContent?: (content: string) => void }) => {\n\tconst textareaRef = useRef<HTMLTextAreaElement | null>(null);\n\n\tconst [mode, setMode] = useState<ViewMode>(\"split\");\n\n\tconst toolbarActions = createToolbarActions();\n\n\tconst {\n\t\tcontent,\n\t\tselection,\n\t\tcurrentBlock,\n\t\tupdateContent,\n\t\tsetSelection,\n\t\tundo,\n\t\tredo,\n\t\tcanUndo,\n\t\tcanRedo\n\t} = useEditor(defaultContent || `# Welcome to the Editor\n\nStart writing your **markdown** content here.\n\n## Features\n\n- Live preview\n- Keyboard shortcuts\n- Block-based editing\n- Extensible architecture\n\n\\`\\`\\`jsx\nimport { MarkdownEditor } from \"@/components/ui/markdown\";\n\nexport default function Page() {\n\treturn <MarkdownEditor />\n}\n\\`\\`\\`\n\n> This is a quote block\n\nHappy writing! ✨\n  `);\n\tuseMarkdownShortcuts(textareaRef, updateContent);\n\n\tconst handleToolbarAction = useCallback((action: ToolbarAction) => {\n\t\tconst result = action.handler(content, selection);\n\t\tupdateContent(result.content, result.selection);\n\n    if (onChangeContent) {\n      onChangeContent(result.content);\n    }\n\t\t\n\t\tsetTimeout(() => {\n\t\t\tif (textareaRef.current) {\n\t\t\t\ttextareaRef.current.focus();\n\t\t\t\ttextareaRef.current.setSelectionRange(result.selection.start, result.selection.end);\n\t\t\t}\n\t\t}, 0);\n\t}, [content, selection, updateContent]);\n\n\treturn (\n\t\t<Card className=\"flex h-auto gap-0 shadow-none p-0 overflow-hidden\">\n\t\t\t<Editor.Toolbar\n\t\t\t\tactions={toolbarActions}\n\t\t\t\tonAction={handleToolbarAction}\n\t\t\t\tcurrentBlock={currentBlock}\n\t\t\t\tundo={undo}\n\t\t\t\tredo={redo}\n\t\t\t\tcanUndo={canUndo}\n\t\t\t\tcanRedo={canRedo}\n\t\t\t\tmode={mode}\n\t\t\t\tsetMode={setMode}\n\t\t\t/>\n\n\t\t\t<div className=\"w-full h-[700px] flex gap-2 p-2\">\n\t\t\t\t{\n\t\t\t\t\t(mode === \"edit\" || mode === \"split\") && (\n\t\t\t\t\t\t<Card className=\"flex gap-4 shadow-none w-full p-0 h-full overflow-auto\">\n\t\t\t\t\t\t\t<Editor.Core \n\t\t\t\t\t\t\t\tcontent={content}\n\t\t\t\t\t\t\t\tonChange={updateContent}\n\t\t\t\t\t\t\t\tonSelectionChange={setSelection}\n\t\t\t\t\t\t\t\ttextareaRef={textareaRef}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</Card>\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t(mode === \"preview\" || mode === \"split\") && (\n\t\t\t\t\t\t<Card className=\"flex gap-4 shadow-none w-full p-0 h-full overflow-auto\">\n\t\t\t\t\t\t\t<Editor.Preview content={content} />\n\t\t\t\t\t\t</Card>\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t</div>\n\n\t\t\t<div className=\"flex justify-end gap-6 px-6 py-2 bg-background border-t border-border text-xs text-zinc-500\">\n        <span className=\"flex items-center\">\n          {currentBlock ? `${currentBlock.type}${currentBlock.level ? ` (H${currentBlock.level})` : ''}` : 'paragraph'}\n        </span>\n        <span className=\"flex items-center\">\n          {content.split('\\n').length} lines · {content.length} chars\n        </span>\n      </div>\n\t\t</Card>\n\t)\n}\n\nconst Editor = {\n  Core: EditorCore,\n  Toolbar: EditorToolbar,\n  Preview: MarkdownPreview\n}\n\nexport {\n  Editor,\n  MarkdownEditor,\n  useEditor,\n  useMarkdownShortcuts,\n  createToolbarActions,\n  type ToolbarAction,\n  type ViewMode\n};\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:block"
}